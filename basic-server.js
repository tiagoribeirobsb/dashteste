import http from 'http';
import https from 'https';
import url from 'url';
import fs from 'fs';

const PORT = 3001;

// Carregar vari√°veis de ambiente
let envVars = {};
try {
  const envContent = fs.readFileSync('.env', 'utf8');
  envContent.split('\n').forEach(line => {
    const [key, ...valueParts] = line.split('=');
    if (key && valueParts.length > 0) {
      envVars[key.trim()] = valueParts.join('=').trim();
    }
  });
} catch (error) {
  console.log('‚ö†Ô∏è Arquivo .env n√£o encontrado, usando apenas dados mockados');
}

// Vari√°veis para token do Metabase
let MB_TOKEN = null;
let MB_EXP = 0;

// Contador para debug
let FUNCTION_CALL_COUNT = 0;

async function makeRequest(urlString, options = {}) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(urlString);
    const isHttps = urlObj.protocol === 'https:';
    const lib = isHttps ? https : http;
    
    const reqOptions = {
      hostname: urlObj.hostname,
      port: urlObj.port || (isHttps ? 443 : 80),
      path: urlObj.pathname + urlObj.search,
      method: options.method || 'GET',
      headers: options.headers || {}
    };
    
    const req = lib.request(reqOptions, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          const jsonData = JSON.parse(data);
          resolve({ status: res.statusCode, data: jsonData });
        } catch (e) {
          resolve({ status: res.statusCode, data: data });
        }
      });
    });
    
    req.on('error', (error) => {
      console.log('‚ùå Erro na requisi√ß√£o HTTP:', error.message);
      reject(error);
    });
    
    if (options.body) {
      req.write(options.body);
    }
    
    req.end();
  });
}

async function loginToMetabase() {
  if (!envVars.MB_URL || !envVars.MB_USER || !envVars.MB_PASS) {
    throw new Error('Credenciais do Metabase n√£o configuradas');
  }
  
  console.log('üîë Fazendo login no Metabase...');
  console.log('üîó URL:', envVars.MB_URL);
  console.log('üë§ User:', envVars.MB_USER);
  
  const response = await makeRequest(`${envVars.MB_URL}/api/session`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      username: envVars.MB_USER,
      password: envVars.MB_PASS
    })
  });
  
  if (response.status !== 200 || !response.data.id) {
    throw new Error(`Login falhou: ${response.status} - ${JSON.stringify(response.data)}`);
  }
  
  MB_TOKEN = response.data.id;
  MB_EXP = Date.now() + 50 * 60 * 1000; // 50 minutos
  console.log('‚úÖ Login no Metabase realizado com sucesso');
  return MB_TOKEN;
}

async function queryMetabaseCard(cardId, parameters = []) {
  FUNCTION_CALL_COUNT++;
  process.stdout.write(`üî•üî•üî• CHAMADA #${FUNCTION_CALL_COUNT} DA FUN√á√ÉO! üî•üî•üî•\n`);
  process.stdout.write('üö®üö®üö® STDOUT - IN√çCIO ABSOLUTO DA FUN√á√ÉO üö®üö®üö®\n');
  process.stderr.write('üö®üö®üö® STDERR - IN√çCIO ABSOLUTO DA FUN√á√ÉO üö®üö®üö®\n');
  console.log('=== TESTE LOG ===');
  console.log(`üöÄ IN√çCIO - queryMetabaseCard chamada para card ${cardId}`);
  console.log('‚úÖ LOGS INICIAIS EXECUTADOS COM SUCESSO!');
  console.log(`üìä Consultando Metabase card ${cardId}...`);
  
  // Verificar se precisa fazer login
  if (!MB_TOKEN || Date.now() > MB_EXP) {
    console.log('üîë Token n√£o existe ou expirado, fazendo login...');
    console.log('üö® PRESTES A CHAMAR loginToMetabase üö®');
    await loginToMetabase();
    console.log('‚úÖ loginToMetabase CONCLU√çDO!');
  }
  
  console.log(`üåê Fazendo requisi√ß√£o para: ${envVars.MB_URL}/api/card/${cardId}/query`);
  console.log('üìù Par√¢metros:', JSON.stringify(parameters));
  
  const response = await makeRequest(`${envVars.MB_URL}/api/card/${cardId}/query`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Metabase-Session': MB_TOKEN
    },
    body: JSON.stringify({
      ignore_cache: true,
      parameters
    })
  });
  
  console.log('üì° Resposta recebida do Metabase');
  
  if (response.status === 401) {
    console.log('üîÑ Token expirado, renovando...');
    MB_TOKEN = null;
    return queryMetabaseCard(cardId, parameters);
  }
  
  process.stdout.write(`üîç Status HTTP: ${response.status} (tipo: ${typeof response.status})\n`);
  
  // Metabase pode retornar 200 ou 202 para queries bem-sucedidas
  if (response.status !== 200 && response.status !== 202) {
    process.stdout.write(`üö® PRESTES A LAN√áAR ERRO - STATUS ${response.status} N√ÉO √â 200 NEM 202 üö®\n`);
    throw new Error(`üö® Status HTTP inv√°lido! Chamada #${FUNCTION_CALL_COUNT}, CardId: ${cardId}, Params: ${JSON.stringify(parameters)}, Status: ${response.status}, Data: ${JSON.stringify(response.data)}`);
  }
  
  process.stdout.write('‚úÖ STATUS 200 - CONTINUANDO...\n');
  
  process.stdout.write(`üîç Status da query: ${response.data.status}\n`);
  process.stdout.write(`üîç Chaves da resposta: ${Object.keys(response.data)}\n`);
  process.stdout.write(`üîç Tem data? ${!!response.data.data}\n`);
  
  // Verificar se a query foi completada com sucesso
  if (response.data.status !== 'completed') {
    throw new Error(`Query n√£o completada: ${response.data.status}`);
  }
  
  if (!response.data || !response.data.data || !response.data.data.cols || !response.data.data.rows) {
    console.log('üîç Estrutura data:', response.data ? Object.keys(response.data) : 'null');
    console.log('üîç Estrutura data.data:', response.data.data ? Object.keys(response.data.data) : 'null');
    throw new Error('Resposta inv√°lida do Metabase');
  }
  
  const cols = response.data.data.cols.map(c => c.display_name || c.name);
  const rows = response.data.data.rows.map(row => 
    Object.fromEntries(cols.map((c, i) => [c, row[i]]))
  );
  
  console.log(`‚úÖ Card ${cardId} consultado: ${rows.length} linhas`);
  return rows;
}

// Dados mockados
const mockData = {
  1: { success: true, data: { value: 2500000, format: 'currency', change: 15.5 } },
  2: { success: true, data: { value: 23.8, format: 'percentage', change: 2.3 } },
  3: { success: true, data: { value: 1247, format: 'number', change: 8.7 } },
  4: { 
    success: true, 
    data: {
      chartType: 'line',
      data: {
        labels: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun'],
        datasets: [{
          label: 'Vendas (R$)',
          data: [180000, 220000, 195000, 240000, 280000, 320000],
          borderColor: 'rgb(75, 192, 192)',
          backgroundColor: 'rgba(75, 192, 192, 0.2)',
          tension: 0.1
        }]
      }
    }
  },
  5: { 
    success: true, 
    data: {
      columns: ['Cliente', 'Receita', 'Pedidos'],
      data: [
        ['Empresa ABC Ltda', 'R$ 125.000', '45'],
        ['Com√©rcio XYZ S.A.', 'R$ 98.500', '32'],
        ['Ind√∫stria 123', 'R$ 87.200', '28']
      ]
    }
  },
  6: { success: true, data: { value: 1850, format: 'currency', change: 5.2 } },
  7: { 
    success: true, 
    data: {
      chartType: 'doughnut',
      data: {
        labels: ['Produtos', 'Servi√ßos', 'Consultoria', 'Suporte'],
        datasets: [{
          data: [45, 30, 15, 10],
          backgroundColor: [
            'rgba(255, 99, 132, 0.8)',
            'rgba(54, 162, 235, 0.8)',
            'rgba(255, 205, 86, 0.8)',
            'rgba(75, 192, 192, 0.8)'
          ]
        }]
      }
    }
  },
  8: { success: true, data: { value: 87.5, format: 'percentage', change: 12.3 } }
};

const server = http.createServer(async (req, res) => {
  const parsedUrl = url.parse(req.url, true);
  const path = parsedUrl.pathname;
  const method = req.method;
  
  console.log(new Date().toISOString(), method, path);
  
  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, x-tenant');
  
  if (method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }
  
  if (path === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ 
      status: 'ok', 
      timestamp: new Date().toISOString() 
    }));
    return;
  }
  
  // Rota do proxy BI
  const biMatch = path.match(/^\/bi\/card\/(\d+)\/query$/);
  if (biMatch && method === 'POST') {
    const cardId = parseInt(biMatch[1]);
    const tenant = parsedUrl.query.tenant || 'default';
    console.log(`üìä Requisi√ß√£o para card ${cardId} (tenant: ${tenant})`);
    
    try {
      // Tentar conectar com Metabase real primeiro
      if (envVars.MB_URL && envVars.MB_USER && envVars.MB_PASS) {
        let rows;
        
        try {
          // Primeiro tentar com par√¢metro tenant
          const params = [{
            type: "category",
            target: ["variable", ["template-tag", "tenant"]],
            value: tenant
          }];
          console.log(`üîÑ Tentando card ${cardId} com par√¢metro tenant...`);
          console.log('üö® PRESTES A CHAMAR queryMetabaseCard üö®');
          rows = await queryMetabaseCard(cardId, params);
        } catch (paramError) {
          console.log(`üîÑ Card ${cardId} n√£o aceita par√¢metro tenant (${paramError.message}), tentando sem par√¢metros...`);
          // Se falhar, tentar sem par√¢metros
          try {
            rows = await queryMetabaseCard(cardId, []);
          } catch (noParamError) {
            console.log(`‚ùå Falha na segunda tentativa sem par√¢metros:`, noParamError.message);
            throw noParamError;
          }
        }
        
        console.log(`‚úÖ Dados reais obtidos para card ${cardId}:`, rows.length, 'linhas');
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: true, data: rows }));
        return;
      }
    } catch (metabaseError) {
      console.warn(`‚ö†Ô∏è Falha ao conectar com Metabase para card ${cardId}:`);
      console.warn(`üö® ERRO COMPLETO:`, metabaseError);
      console.warn(`üìù MENSAGEM:`, metabaseError.message);
      console.warn(`‚ö†Ô∏è Stack trace:`, metabaseError.stack);
    }
    
    // Usar dados mockados como fallback
    if (mockData[cardId]) {
      console.log(`üé≠ Usando dados mockados para card ${cardId}`);
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify(mockData[cardId]));
    } else {
      console.log(`‚ùå Card ${cardId} n√£o encontrado nem nos dados reais nem mockados`);
      res.writeHead(404, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ 
        success: false, 
        error: `Card ${cardId} n√£o encontrado` 
      }));
    }
    return;
  }
  
  // 404 para outras rotas
  console.log(`‚ùå Endpoint n√£o encontrado: ${method} ${path}`);
  res.writeHead(404, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ error: 'Not found' }));
});

server.listen(PORT, () => {
  console.log(`üöÄ Servidor b√°sico rodando na porta ${PORT}`);
  console.log(`üìä Endpoint dispon√≠vel: POST /bi/card/:id/query`);
  console.log(`üè• Health check: GET /health`);
});

// Tratamento de erros
server.on('error', (err) => {
  console.error('‚ùå Erro no servidor:', err);
});

process.on('uncaughtException', (err) => {
  console.error('‚ùå Exce√ß√£o n√£o capturada:', err);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Promise rejeitada:', reason);
});